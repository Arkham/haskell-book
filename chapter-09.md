# Lists

Lists do double duty in Haskell:
- a collection of values
- an infinite series of values

## datatype

`data [] a = [] | a : [a]`

The datatype with type constructor `[]` takes a single type constructor
argument `a`.  It can be constructed via:

- a nullary constructor `[]`
- a data constructor called _cons_ `(:)` which is a product of:
  - a value of type `a`
  - a value of type `[a]`

## pattern matching on lists

```
Prelude> myHead (x : _) = x
Prelude> :t myHead
myHead :: [t] -> t
Prelude> myHead [1,2,3]
1
Prelude> myTail (_ : xs) = xs
Prelude> myTail [1,2,3]
[2,3]
```

This seems good, but...

```
Prelude> myHead []
*** Exception: <interactive>:1:1-18: Non-exhaustive patterns in function
```

So the proper way to write that would be

```
myTail :: [a] -> [a]
myTail [] = []
myTail (_ : xs) = xs
```

so how could we write myHead?

```
myHead :: [a] -> Maybe a
myHead [] = Nothing
myHead (x : _) = Just x
```

## cons cells and spines

The cons cells are the `a : [a]`, the result of recursively prepending a value
to a list.

The spine is the connective structure that holds the cons cells together and in
place. This structure nests the cons cells rather than ordering them in a right
to left row.

## ranges

```
Prelude> [1..10]
[1,2,3,4,5,6,7,8,9,10]
Prelude> enumFromTo 1 10
[1,2,3,4,5,6,7,8,9,10]

Prelude> [1,2..10]
[1,2,3,4,5,6,7,8,9,10]
Prelude> enumFromThenTo 1 2 10
[1,2,3,4,5,6,7,8,9,10]

Prelude> [1,3..10]
[1,3,5,7,9]
Prelude> enumFromThenTo 1 3 10

[1,3,5,7,9]Prelude> ['t'..'z']
"tuvwxyz"
Prelude> enumFromTo 't' 'z'
"tuvwxyz"
```

You can also generate infinite lists using `enumFrom` and `enumFromThen`.

```
Prelude> :info Enum
class Enum a where
  succ :: a -> a
  pred :: a -> a
  toEnum :: Int -> a
  fromEnum :: a -> Int
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromTo :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]
  {-# MINIMAL toEnum, fromEnum #-}
```

## Portions of lists

```
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
```

```
Prelude> take 7 ['a'..'z']
"abcdefg"
Prelude> take 3 [1..10]
[1,2,3]
Prelude> take 3 []
[]
```

But we can also take from infinite lists, such as the one generated by
`enumFrom`.

```
Prelude> take 5 $ enumFrom 1
[1,2,3,4,5]
```

```
Prelude> drop 5 [1..10]
[6,7,8,9,10]

Prelude> splitAt 5 [1..10]
([1,2,3,4,5],[6,7,8,9,10])

Prelude> splitAt 5 []
([],[])
```

Other functions wait for a condition to be true:

```
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]

Prelude> takeWhile (<3) [1..10]
[1,2]

Prelude> takeWhile (>6) [1..10]
[]
```

## List comprehensions

```
Prelude> [ x^2 | x <- [1..10] ]
[1,4,9,16,25,36,49,64,81,100]

Prelude> take 5 [ x^2 | x <- enumFrom 17 ]
[289,324,361,400,441]

Prelude> [ x^2 | x <- [1..10], rem x 2 == 0 ]
[4,16,36,64,100]
```

We can also write list comprehensions that have multiple generators. One thing
to note is that the rightmost generator will be exhausted first, then the second
rightmost, and so on.

```
Prelude> [ x^y | x <- [1..5], y <- [2, 3]]
[1,1,4,8,9,27,16,64,25,125]

Prelude> [ x^y | x <- [1..10], y <- [2, 3], x^y < 200]
[1,1,4,8,9,27,16,64,25,125,36,49,64,81,100]

Prelude> [ (x, y) | x <- [1, 2, 3], y <- ['a', 'b']]
[(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
```

## comprehension with strings

```
Prelude> :t elem
elem :: (Eq a, Foldable t) => a -> t a -> Bool

Prelude> elem 'a' "abra"
True
Prelude> elem 'f' "abra"
False
```

```
Prelude> [ x | x <- "Three Letter Acronym", elem x ['A'..'Z'] ]
"TLA"
```

## spines and nonstrict evaluation

When we talk about lists in Haskell, we talk about them having a _spine_. This
is the connective structure that ties the collection of values together. In the
case of lists, the spine is represented by the recursive cons operator. When we
have a list like `[1, 2, 3]` we can write it as

```
1 : 2 : 3 : []

or

1 : (2 : (3 : []) )

or

  :
 / \
1   :
   / \
  2   :
     / \
    3  []
```

The problem with writing `1 : (2 : [])` is that it seems that the value `1`
exists before the `cons` cell, but actually the cons cell contains the values.
Because of the way nonstrict evaluation works, you can evaluate cons cells
independently of what they contain. It is poissible to

- evaluate only the spine without evaluating individual values.
- evaluate only part of the spine and not the rest of it.

The list isn't constructed until it's consumed! Nothing is evaluated until it
must be.

## :sprint

```
Prelude> blah = enumFromTo 'a' 'z'
Prelude> :sprint blah
blah = _
Prelude> take 1 blah
"a"
Prelude> :sprint blah
blah = 'a' : _
Prelude> take 2 blah
"ab"
Prelude> :sprint blah
blah = 'a' : 'b' : _
Prelude> length blah
26
Prelude> :sprint blah
blah = "abcdefghijklmnopqrstuvwxyz"
```

In the last example, evaluating the length of a list should not also evaluate
the values. This is a GHCi quirk.

## spines are evaluated independently of values

Values in Haskell get reduced to weak head normal form by default: WHNF means
that the expression is only evaluated as far as is necessary to reach a data
constructor.

```
(1, 1) -- Both WHNF & NF

(1, 1 + 1) -- Only WHNF

\x -> x * 10 -- Both WHNF & NF

"Papu" ++ "chon"
-- This is neither WHNF nor NF because the outermost expression is a function
whose arguments are fully applied but hasn't been evaluated

(1, "Papu" ++ "chon") -- WHNF, but not NF
```

Let's look at another example

```
Prelude> num :: [Int]; num = [1..10]
Prelude> :sprint num
num = _
Prelude> take 2 num
[1,2]
Prelude> :sprint num
num = 1 : 2 : _
```

With `take 2` we only need to evaluate the first two cons cells and the values
they contain. If we had evaluated to normal form we would have had to recurse
through the entire list, forcing the entire spine and the values each cons cell
contained.

So by default a list that is awaiting evaluation looks like this

```
  :
 / \
_   _
```

Some functions can force the evaluation of the spine without causing the
evaluation of each value. For example if we did `length [1, 2, 3]`

```
  :
 / \
_   :
   / \
  _   :
     / \
    _  []
```

For example this would still work

```
Prelude> x = [1, undefined, 3]
Prelude> length x
3
```

if we had to rewrite `length` it could be like this

```
myLength :: [a] -> Integer
myLength [] = 0
myLength (_:xs) = 1 + length xs
```

In this way we only pattern match against `:` and the compiler can know for sure
that we are never going to evaluate the current value `_`. However if part of
the spine itself is bottom we will get an error

```
Prelude> x = [1] ++ undefined ++ [3]
Prelude> length x
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:56:12 in interactive:Ghci35
```

If we wrote a version of the `sum` function we would have something that
evaluates both the spine and the cons cells.

```
mySum :: Num a => [a] -> a
mySum [] = 0
mySum (x:xs) = x + mySum xs
```

This function will keep recursing until it hits the empty list. Then it will
start going back up the spine of the list, summing the values as it goes. It
will take some time to develop intuition of Haskell's evaluation strategies.

## transforming lists of values

Let's look at `map` and `fmap`

```
Prelude> :t map
map :: (a -> b) -> [a] -> [b]
Prelude> :t fmap
fmap :: Functor f => (a -> b) -> f a -> f b

Prelude> map (+1) [1, 2, 3, 4]
[2,3,4,5]
Prelude> map (1-) [1, 2, 3, 4]
[0,-1,-2,-3]

Prelude> fmap (+1) [1, 2, 3, 4]
[2,3,4,5]
Prelude> fmap (2*) [1, 2, 3, 4]
[2,4,6,8]

Prelude> map id [1, 2, 3]
[1,2,3]
Prelude> fmap id [1, 2, 3]
[1,2,3]
```

Even map does not resolve all values of a list if it does not have to

```
Prelude> map (+1) [1, 2, undefined]
[2,3,*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:106:17 in interactive:Ghci55

Prelude> take 2 $ map (+1) [1, 2, undefined]
[2,3]
```

Of course you can use these functions with other fn and list types

```
Prelude> map fst [(1,2), (3,4)]
[1,3]
Prelude> fmap fst [(1,2), (3,4)]
[1,3]

Prelude> map (take 3) [[1..5], [5..10], [10..15]]
[[1,2,3],[5,6,7],[10,11,12]]
```

## filtering values

```
Prelude> :t filter
filter :: (a -> Bool) -> [a] -> [a]

Prelude> filter even [1..10]
[2,4,6,8,10]
```

Next we’re going to work on removing all articles (’the’, ’a’, and ’an’) from
sentences. You want to get to something that works like this:

```
Prelude> myFilter "the brown dog was a goof"
["brown","dog","was","goof"]

Prelude> myFilter = filter (not . flip elem ["the", "a", "an"]) . words
Prelude> myFilter "the brown dog was a goof"
["brown","dog","was","goof"]
```

## zipping lists

```
Prelude> :t zip
zip :: [a] -> [b] -> [(a, b)]

Prelude> zip [1,2,3] [4,5,6]
[(1,4),(2,5),(3,6)]

Prelude> zip [1,2,3] [4]
[(1,4)]

Prelude> zip [1] [4,5,6]
[(1,4)]
```

You can use unzip to revert this

```
unzip [(1,2), (5,6)]
([1,5],[2,6])
```

Or pass a custom function to zip things with

```
Prelude> zipWith (+) [1,2,3] [4,5,6]
[5,7,9]
```

## definitions

- A _product type_ is a type made of a set of types compounded over each other. In
  Haskell product types are represented by tuples of data constructors with more
  than one argument. If you have a product of `Bool` and `Int` your terms will
  each contain a `Bool` and an `Int` value.
- A _sum type_ of two types is a type whose terms are in either type, but never
  simultaneously. In Haskell these types are represented by a pipe `|`. If you
  have a sum of `Bool` and `Int` your terms will be either a `Bool` or an `Int`.
- _Cons_ is used as a verb to signify that a list value has been created by
  connecting a value onto the head of another list. Its operator is `:`.
- _Cons cell_ is a data constructor and a product of the types `a` and `[a]`. It
  allows for nesting of multiple cons cells, possibly indefinitely using
  recursive functions.
- The _spine_ is a way to refer to the structure that glues a collection of
  values together. The spine is the structure of collection that is NOT the
  values contained in it.
